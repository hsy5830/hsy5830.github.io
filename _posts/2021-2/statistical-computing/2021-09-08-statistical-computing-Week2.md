---
layout: single
title:  "[Advanced Statistical Computing] Julia Introduction 2"
date:   2021-09-01 16:27:00 +0530
categories: Statcom
tags : Julia
toc: true
toc_sticky: true
toc_label: "Contents"
---
참고 : Julia Intro 2
<br>

# Matrices and Vectors

## Dimensions(차원)

```julia
x = randn(5,3)

size(x) # (5,3) : 전체 차원 수
size(x, 1) # 5 : 행의 수
size(x, 2) # 3 : 열의 수
length(x) # 15 : 전체 성분의 수
```
<br>

## Indexing(인덱싱)

```julia
x = randn(5,5) # 5x5 행렬

x[:, 1] # 1st column
x[1, :] # 1st row
x[1:2, 2:3] # sub-array / 1~2행, 2~3열 선택
```
파이썬과 다르게, 줄리아에선 인덱싱을 할 때 마지막 번호의 인덱스가 제외되지 않는다.
<br><br>

```julia
z = x[1:2, 2:3]

# 같은 코드
z = view(x, 1:2, 2:3)
@views z = x[1:2, 2:3]
```
위의 두 코드 모두 z에 x 부분행렬을 저장하게 되는데, 두 방법에는 차이가 있다.<br>
`z = x[1:2, 2:3]` 의 경우에는 메모리를 새롭게 할당(allocate)하여 z라는 변수에 x의 부분행렬을 저장하는 것이지만, `z = view(x, 1:2, 2:3)` 의 경우엔 같은 포인터를 가리키는 하나의 변수로서 z를 이용하게 된다.

```julia
z[2,2] = 0.0
```
z의 2행 2열 성분을 초기화하면, 
```julia
x # z = x[1:2, 2:3]
```
```
5×5 Matrix{Float64}:
  1.56701    0.11162     1.50172   -1.04396    0.271254
 -0.385128  -0.0208861   0.726587   0.155334   1.78307
  1.85628   -1.35106    -0.474294  -0.29979   -0.629733
 -0.878317   0.640118   -0.700664   0.467584  -0.289654
 -0.946056  -0.40254    -0.594829   0.857244  -0.527352
```
x의 성분은 변하지 않는다.


```julia
x # z = view(x, 1:2, 2:3)
```
```
5×5 Matrix{Float64}:
  1.56701    0.11162     1.50172   -1.04396    0.271254
 -0.385128  -0.0208861   0.0        0.155334   1.78307
  1.85628   -1.35106    -0.474294  -0.29979   -0.629733
 -0.878317   0.640118   -0.700664   0.467584  -0.289654
 -0.946056  -0.40254    -0.594829   0.857244  -0.527352
```
x의 성분도 z와 함께 변경된 것을 확인할 수 있다. C/C++ 에서 나오는 `깊은 복사`, `얕은 복사`와 비슷한 개념으로 이해할 수 있다.

<br>

### *mutable* vs *immutable*

* *mutable object* 

```julia
y = x

pointer(x), pointer(y)
```
```
(Ptr{Float64} @0x000000010df5b890, Ptr{Float64} @0x000000010df5b890)
```
위처럼 단순히 `=`연산자를 이용할 경우 같은 주소를 가리키는 변수로 x,y가 이용된다. 따라서 y의 값을 바꾸면 x의 값도 바뀌게 된다.<br>
<br>

다른 변수에 새로운 객체를 복사하고 싶다면 `copy`함수를 이용한다.
```julia
z = copy(x)

pointer(x), pointer(z)
```
```
(Ptr{Float64} @0x000000010df5b890, Ptr{Float64} @0x000000010dee4ef0)
```
서로 다른 주소값을 갖는 것을 확인할 수 있다.

<br>

* *immutable object*

```julia
a = 1.0  # Float64
b = a
b # 1.0
```
x, y 행렬을 이용하여 실행한 코드와 차이가 없다. 하지만.,

```julia
a = 2.0
b # 1.0
```
행렬을 이용했을 땐 x, y에서 하나의 값만 바꿔주어도 x,y가 가리키는 값이 전부 다 바뀌었는데 a,b의 경우엔 그렇지 않음을 볼 수 있다. 위의 코드의 경우 원래 `a , 1.0` 의 1.0 값을 바꾼 것이 아니라, *immutable object* 인 `2.0`을 생성하고 a가 그것을 가리키게 한다고 해석할 수 있다.

